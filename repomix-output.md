This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-12-06 23:13:39

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
backend
  pom.xml
  src
    main
      java
        com
          example
            mediaservice
              MediaServer.java
              MediaServiceImpl.java
              ProducerClient.java
      proto
        media.proto
frontend
  .gitignore
  config.json
  eslint.config.js
  index.html
  package.json
  README.md
  src
    App.jsx
    components
      VideoGrid.jsx
      VideoPlayer.jsx
    index.css
    main.jsx
    styles
      App.css
  vite.config.js
README.md
```

# Repository Files


## .gitignore

```text
.idea/inspectionProfiles/Project_Default.xml
.idea/vcs.xml
.idea/workspace.xml

# Backend folder
/backend/

# Test videos folder
/test-videos

# Video files
*.mp4
*.avi
*.mov
*.mkv
*.webm
*.flv
*.wmv
*.m4v
```

## backend/pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example</groupId>
    <artifactId>media-service</artifactId>
    <version>1.0-SNAPSHOT</version>
    
    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <grpc.version>1.42.2</grpc.version>
        <protobuf.version>3.19.2</protobuf.version>
        <exec.mainClass>com.example.mediaservice.MediaServer</exec.mainClass>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty-shaded</artifactId>
            <version>${grpc.version}</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
            <version>${grpc.version}</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
            <version>${grpc.version}</version>
        </dependency>
        <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
        </dependency>
    </dependencies>
    
    <build>
        <extensions>
            <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.6.2</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.6.1</version>
                <configuration>
                    <protocArtifact>com.google.protobuf:protoc:${protobuf.version}:exe:${os.detected.classifier}</protocArtifact>
                    <pluginId>grpc-java</pluginId>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                        <phase>generate-sources</phase>
                    </execution>
                </executions>
            </plugin>
            
            <!-- Add this plugin for executing Java applications -->
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>3.1.0</version>
                <configuration>
                    <mainClass>${exec.mainClass}</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

## backend/src/main/java/com/example/mediaservice/MediaServer.java

```java
package com.example.mediaservice;

import io.grpc.Server;
import io.grpc.ServerBuilder;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetSocketAddress;
import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpExchange;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.io.FileInputStream;
import java.net.InetAddress;

public class MediaServer {
    private final int grpcPort;
    private final int httpPort;
    private final Server grpcServer;
    private final HttpServer httpServer;
    private final MediaServiceImpl mediaService;
    private final String bindAddress;

    public MediaServer(int grpcPort, int httpPort, int maxQueueSize, int consumerThreads, String bindAddress) {
        this.grpcPort = grpcPort;
        this.httpPort = httpPort;
        this.bindAddress = bindAddress;
        this.mediaService = new MediaServiceImpl(maxQueueSize, consumerThreads, "./videos");
        this.grpcServer = ServerBuilder.forPort(grpcPort)
                    .addService(mediaService)
                    .maxInboundMessageSize(50 * 1024 * 1024) // Allow 50MB uploads
                    .build();
        this.httpServer = createHttpServer(bindAddress);
    }

    private HttpServer createHttpServer(String bindAddress) {
        try {
            InetAddress address = InetAddress.getByName(bindAddress);
            HttpServer server = HttpServer.create(new InetSocketAddress(address, httpPort), 0);

            // API endpoints
            server.createContext("/api/stats", new StatsHandler());
            server.createContext("/api/videos", new VideosHandler());

            // Static content serving
            server.createContext("/content/", new StaticContentHandler());

            server.setExecutor(null);
            return server;
        } catch (IOException e) {
            throw new RuntimeException("Failed to create HTTP server", e);
        }
    }

    public void start() throws IOException {
        grpcServer.start();
        httpServer.start();

        System.out.println("Media Server started:");
        System.out.println("gRPC Server on port: " + grpcPort + " (" + bindAddress + ")");
        System.out.println("HTTP Server on port: " + httpPort + " (" + bindAddress + ")");
        System.out.println("Static content available at: http://[SERVER_IP]:" + httpPort + "/content/");

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            System.err.println("Shutting down servers...");
            MediaServer.this.stop();
            System.err.println("Servers shut down");
        }));
    }

    public void stop() {
        if (grpcServer != null) {
            grpcServer.shutdown();
        }
        if (httpServer != null) {
            httpServer.stop(0);
        }
    }

    private void blockUntilShutdown() throws InterruptedException {
        if (grpcServer != null) {
            grpcServer.awaitTermination();
        }
    }

    // HTTP Handlers
    class StatsHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) {
            try {
                if ("GET".equals(exchange.getRequestMethod())) {
                    // Set CORS headers
                    exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                    exchange.getResponseHeaders().set("Content-Type", "application/json");

                    String response = String.format(
                        "{\"queueSize\": %d, \"maxQueue\": %d, \"droppedCount\": %d}",
                        mediaService.getQueueSize(),
                        mediaService.getMaxQueueSize(),
                        mediaService.getDroppedCount()
                    );

                    exchange.sendResponseHeaders(200, response.getBytes().length);
                    OutputStream os = exchange.getResponseBody();
                    os.write(response.getBytes());
                    os.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    class VideosHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) {
            try {
                if ("GET".equals(exchange.getRequestMethod())) {
                    exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                    exchange.getResponseHeaders().set("Content-Type", "application/json");
                    
                    // Get videos and filter out previews ONLY
                    List<VideoInfo> videoList = new ArrayList<>(mediaService.getVideoStore().values());
                    
                    // Remove only previews (keep compressed videos)
                    videoList.removeIf(video -> 
                        video.getFilename().contains("_preview")
                        // REMOVE this line: || video.getFilename().startsWith("compressed_")
                    );
                    
                    String response = convertVideoListToJson(videoList);
                    
                    exchange.sendResponseHeaders(200, response.getBytes().length);
                    OutputStream os = exchange.getResponseBody();
                    os.write(response.getBytes());
                    os.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        private String convertVideoListToJson(List<VideoInfo> videos) {
            StringBuilder json = new StringBuilder("[");
            for (int i = 0; i < videos.size(); i++) {
                VideoInfo video = videos.get(i);
                
                // Get compressed size, but if it's 0, check if there's a compressed file
                long compressedSize = video.getCompressedSize();
                if (compressedSize == 0) {
                    // Check if compressed file exists
                    String compressedFilename = "compressed_" + video.getFilename();
                    Path compressedPath = Paths.get("./videos", compressedFilename);
                    if (Files.exists(compressedPath)) {
                        try {
                            compressedSize = Files.size(compressedPath);
                        } catch (IOException e) {
                            // Keep as 0
                        }
                    }
                }
                
                String jsonEntry = String.format(
                    "{\"id\":\"%s\",\"filename\":\"%s\",\"upload_time\":\"%s\",\"size\":%d,\"client_id\":\"%s\",\"compressed_size\":%d}",
                    video.getId(),
                    video.getFilename(),
                    video.getUploadTime(),
                    video.getSize(),
                    video.getClientId(),
                    compressedSize  // Use actual compressed size
                );
                
                json.append(jsonEntry);
                if (i < videos.size() - 1) json.append(",");
            }
            json.append("]");
            return json.toString();
        }
    }

    class StaticContentHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) {
            try {
                String path = exchange.getRequestURI().getPath();
                
                // Allow three paths now
                if (!path.startsWith("/content/videos/") && 
                    !path.startsWith("/content/previews/") &&
                    !path.startsWith("/content/compressed/")) {
                    String response = "Invalid path. Use /content/videos/, /content/previews/, or /content/compressed/";
                    exchange.getResponseHeaders().set("Content-Type", "text/plain");
                    exchange.sendResponseHeaders(400, response.getBytes().length);
                    exchange.getResponseBody().write(response.getBytes());
                    exchange.close();
                    return;
                }
                
                String filename = path.replace("/content/videos/", "")
                                    .replace("/content/previews/", "")
                                    .replace("/content/compressed/", "");
                
                java.nio.file.Path filePath;
                
                if (path.startsWith("/content/previews/")) {
                    // Serve previews
                    filePath = Paths.get("./videos/previews", filename);
                } else if (path.startsWith("/content/compressed/")) {
                    // Serve compressed videos
                    filePath = Paths.get("./videos", filename);
                    // Don't block compressed files anymore
                } else {
                    // Serve regular videos
                    filePath = Paths.get("./videos", filename);
                    
                    // Only block previews from main videos directory
                    if (filename.contains("_preview")) {
                        String response = "Access denied - this is a preview file";
                        exchange.getResponseHeaders().set("Content-Type", "text/plain");
                        exchange.sendResponseHeaders(403, response.getBytes().length);
                        exchange.getResponseBody().write(response.getBytes());
                        exchange.close();
                        return;
                    }
                }
                
                // Rest of the method remains the same...
                if (Files.exists(filePath)) {
                    exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                    exchange.getResponseHeaders().set("Content-Type", getContentType(filename));
                    exchange.getResponseHeaders().set("Cache-Control", "no-cache");
                    
                    long fileSize = Files.size(filePath);
                    exchange.sendResponseHeaders(200, fileSize);
                    
                    try (OutputStream os = exchange.getResponseBody();
                        InputStream is = Files.newInputStream(filePath)) {
                        byte[] buffer = new byte[8192];
                        int bytesRead;
                        while ((bytesRead = is.read(buffer)) != -1) {
                            os.write(buffer, 0, bytesRead);
                        }
                    }
                } else {
                    String response = "File not found: " + filename;
                    exchange.getResponseHeaders().set("Content-Type", "text/plain");
                    exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                    exchange.sendResponseHeaders(404, response.getBytes().length);
                    exchange.getResponseBody().write(response.getBytes());
                }
            } catch (IOException e) {
                System.err.println("Error serving static content: " + e.getMessage());
            } finally {
                exchange.close();
            }
        }
    
        
        private String getContentType(String filename) {
            if (filename.endsWith(".mp4")) return "video/mp4";
            if (filename.endsWith(".avi")) return "video/x-msvideo";
            if (filename.endsWith(".mov")) return "video/quicktime";
            if (filename.endsWith(".mkv")) return "video/x-matroska";
            return "application/octet-stream";
        }
    }

    public static void main(String[] args) throws Exception {
        // Default values
        int grpcPort = 9090;
        int httpPort = 8080;
        int maxQueueSize = 10;
        int consumerThreads = 3;
        String bindAddress = "0.0.0.0";

        // Load configuration from config.properties
        Properties config = new Properties();
        try {
            String configPath = "./config.properties";
            if (Files.exists(Paths.get(configPath))) {
                try (FileInputStream fis = new FileInputStream(configPath)) {
                    config.load(fis);
                    System.out.println("Loaded configuration from config.properties");
                }
            } else {
                System.out.println("config.properties not found, using defaults");
            }
        } catch (Exception e) {
            System.err.println("Warning: Could not load config.properties: " + e.getMessage());
            System.err.println("Using default values");
        }

        // Read from config file with defaults
        grpcPort = Integer.parseInt(config.getProperty("grpc.port", String.valueOf(grpcPort)));
        httpPort = Integer.parseInt(config.getProperty("http.port", String.valueOf(httpPort)));
        bindAddress = config.getProperty("bind.address", bindAddress);

        if (args.length >= 4) {
            // Use Command Line Arguments if provided
            grpcPort = Integer.parseInt(args[0]);
            httpPort = Integer.parseInt(args[1]);
            maxQueueSize = Integer.parseInt(args[2]);
            consumerThreads = Integer.parseInt(args[3]);
            if (args.length >= 5) bindAddress = args[4];
        } else {
            // Interactive Mode (Best for Demo)
            java.util.Scanner scanner = new java.util.Scanner(System.in);
            System.out.println("=== Media Server Configuration ===");

            System.out.print("Enter Queue Size (q) [default " + maxQueueSize + "]: ");
            String qInput = scanner.nextLine().trim();
            if (!qInput.isEmpty()) maxQueueSize = Integer.parseInt(qInput);

            System.out.print("Enter Consumer Threads (c) [default " + consumerThreads + "]: ");
            String cInput = scanner.nextLine().trim();
            if (!cInput.isEmpty()) consumerThreads = Integer.parseInt(cInput);

            System.out.println("Starting server with Queue=" + maxQueueSize + ", Consumers=" + consumerThreads);
        }

        MediaServer server = new MediaServer(grpcPort, httpPort, maxQueueSize, consumerThreads, bindAddress);
        server.start();
        server.blockUntilShutdown();

    }
}
```

## backend/src/main/java/com/example/mediaservice/MediaServiceImpl.java

```java
package com.example.mediaservice;

import io.grpc.stub.StreamObserver;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;
import java.util.logging.*;

public class MediaServiceImpl extends MediaServiceGrpc.MediaServiceImplBase {
    private final BoundedQueue<QueuedVideo> videoQueue;
    private final Map<String, VideoInfo> videoStore;
    private final Path storageDir;
    private final int consumerThreads;
    private final ExecutorService consumerExecutor;
    private final Logger logger;

    public Map<String, VideoInfo> getVideoStore() {
        return videoStore;
    }

    public MediaServiceImpl(int maxQueueSize, int consumerThreads, String storagePath) {
        this.videoQueue = new BoundedQueue<>(maxQueueSize);
        this.videoStore = new ConcurrentHashMap<>();
        this.consumerThreads = consumerThreads;
        this.storageDir = Paths.get(storagePath);
        this.consumerExecutor = Executors.newFixedThreadPool(consumerThreads);

        // Setup logging
        this.logger = setupLogger();

        try {
            Files.createDirectories(storageDir);
            Files.createDirectories(storageDir.resolve("previews"));
        } catch (IOException e) {
            e.printStackTrace();
        }

        startConsumers();
        setupShutdownHook();
    }

    private Logger setupLogger() {
        try {
            Logger logger = Logger.getLogger("MediaServiceImpl");
            FileHandler fileHandler = new FileHandler("consumer_log.txt");
            fileHandler.setFormatter(new SimpleFormatter());
            logger.addHandler(fileHandler);
            logger.setUseParentHandlers(false);
            return logger;
        } catch (IOException e) {
            return Logger.getGlobal();
        }
    }

    private void setupShutdownHook() {
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            logger.info("Shutdown initiated - closing resources");
            consumerExecutor.shutdown();
            try {
                if (!consumerExecutor.awaitTermination(10, TimeUnit.SECONDS)) {
                    consumerExecutor.shutdownNow();
                }
            } catch (InterruptedException e) {
                consumerExecutor.shutdownNow();
            }
            logger.info("Shutdown completed");
        }));
    }

    private void startConsumers() {
        for (int i = 0; i < consumerThreads; i++) {
            final int consumerId = i;
            consumerExecutor.submit(() -> {
                while (!Thread.currentThread().isInterrupted()) {
                    try {
                        QueuedVideo videoItem = videoQueue.dequeue();
                        processVideo(videoItem, consumerId);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    } catch (Exception e) {
                        logger.warning("Consumer " + consumerId + " error: " + e.getMessage());
                    }
                }
            });
        }
    }

    @Override
    public void uploadVideo(VideoChunk request, StreamObserver<UploadResponse> responseObserver) {
        // Create the internal representation
        QueuedVideo videoItem = new QueuedVideo(
            UUID.randomUUID().toString(),
            request.getFilename(),
            request.getClientId(),
            request.getData().toByteArray()
        );

        try {
            boolean queued = videoQueue.enqueue(videoItem);

            if (queued) {
                responseObserver.onNext(UploadResponse.newBuilder()
                    .setStatus("QUEUED")
                    .setMessage("Video added to queue")
                    .setVideoId(videoItem.getId())
                    .build());
                logger.info("Video queued: " + videoItem.getFilename());
            } else {
                responseObserver.onNext(UploadResponse.newBuilder()
                    .setStatus("DROPPED")
                    .setMessage("Queue is full")
                    .build());
                logger.info("Video dropped (queue full): " + videoItem.getFilename());
            }
        } catch (Exception e) {
            responseObserver.onNext(UploadResponse.newBuilder()
                .setStatus("ERROR")
                .setMessage("Server error: " + e.getMessage())
                .build());
            logger.severe("Error processing upload: " + e.getMessage());
        }
        responseObserver.onCompleted();
    }

    private void processVideo(QueuedVideo videoItem, int consumerId) {
        String safeFilename = null;
        try {
            safeFilename = getSafeFilename(videoItem.getFilename());
            Path filePath = storageDir.resolve(safeFilename);

            logger.info("Consumer " + consumerId + " START processing: " + safeFilename);
            
            // Write video file
            Files.write(filePath, videoItem.getData());
            logger.info("Consumer " + consumerId + " wrote file: " + safeFilename);
            
            // 1. Generate preview
            generatePreview(filePath, consumerId);
            logger.info("Consumer " + consumerId + " generated preview for: " + safeFilename);
            
            // 2. Compress video and get compressed size
            long compressedSize = compressVideo(filePath, consumerId);
            logger.info("Consumer " + consumerId + " compressed video: " + safeFilename + 
                    ", compressed size: " + compressedSize + " bytes");
            
            // Store metadata with ACTUAL compressed size
            VideoInfo videoInfo = VideoInfo.newBuilder()
                .setId(videoItem.getId())
                .setFilename(safeFilename)
                .setUploadTime(new Date().toString())
                .setSize(videoItem.getData().length)
                .setClientId(videoItem.getClientId())
                .setCompressedSize(compressedSize) // ACTUAL size, not 0
                .build();

            videoStore.put(videoItem.getId(), videoInfo);
            logger.info("Consumer " + consumerId + " COMPLETED processing: " + safeFilename + 
                    " (ID: " + videoItem.getId() + ", Original: " + videoItem.getData().length + 
                    " bytes, Compressed: " + compressedSize + " bytes)");
            
        } catch (Exception e) {
            logger.severe("Consumer " + consumerId + " FAILED to process: " + 
                        (safeFilename != null ? safeFilename : videoItem.getFilename()) + 
                        " - Error: " + e.getMessage());
        }
    }

    private long compressVideo(Path inputPath, int consumerId) {
        String compressedFilename = null;
        try {
            String filename = inputPath.getFileName().toString();
            String nameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));
            String extension = filename.substring(filename.lastIndexOf('.'));
            compressedFilename = "compressed_" + nameWithoutExt + extension;
            Path compressedPath = storageDir.resolve(compressedFilename);

            // First, check if the file already exists and is valid
            if (Files.exists(compressedPath)) {
                logger.info("Consumer " + consumerId + " - Compressed file already exists: " + compressedFilename);
                return Files.size(compressedPath); // Return existing file size
            }

            List<String> ffmpegCommand = new ArrayList<>();
            ffmpegCommand.add("ffmpeg");
            ffmpegCommand.add("-i");
            ffmpegCommand.add(inputPath.toAbsolutePath().toString());
            ffmpegCommand.add("-vcodec");
            ffmpegCommand.add("libx264");
            ffmpegCommand.add("-crf");
            ffmpegCommand.add("28");
            ffmpegCommand.add("-preset");
            ffmpegCommand.add("fast");
            ffmpegCommand.add("-acodec");
            ffmpegCommand.add("aac");
            ffmpegCommand.add("-y");
            ffmpegCommand.add(compressedPath.toAbsolutePath().toString());

            ProcessBuilder pb = new ProcessBuilder(ffmpegCommand);
            pb.redirectErrorStream(true);
            
            logger.info("Consumer " + consumerId + " starting compression: " + filename);
            Process process = pb.start();

            // Read output for debugging
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                // You can log this if needed for debugging
                // logger.fine("FFmpeg output: " + line);
            }

            int exitCode = process.waitFor();

            if (exitCode == 0) {
                if (Files.exists(compressedPath)) {
                    long compressedSize = Files.size(compressedPath);
                    logger.info("Consumer " + consumerId + " successfully compressed: " + 
                            filename + " -> " + compressedFilename + 
                            " (" + compressedSize + " bytes)");
                    return compressedSize;
                } else {
                    logger.warning("Consumer " + consumerId + " compression created no output file");
                    return 0;
                }
            } else {
                logger.warning("Consumer " + consumerId + " FFmpeg failed with exit code: " + exitCode);
                return 0;
            }

        } catch (Exception e) {
            logger.warning("Consumer " + consumerId + " compression exception for " + 
                        (compressedFilename != null ? compressedFilename : "unknown") + 
                        ": " + e.getMessage());
            e.printStackTrace();
            return 0;
        }
    }

    private String getSafeFilename(String filename) {
        String baseName = filename.replaceAll("[^a-zA-Z0-9.-]", "_");
        Path filePath = storageDir.resolve(baseName);

        if (!Files.exists(filePath)) {
            return baseName;
        }

        String nameWithoutExt = baseName.substring(0, baseName.lastIndexOf('.'));
        String extension = baseName.substring(baseName.lastIndexOf('.'));
        int counter = 1;

        while (Files.exists(storageDir.resolve(nameWithoutExt + "(" + counter + ")" + extension))) {
            counter++;
        }

        return nameWithoutExt + "(" + counter + ")" + extension;
    }

    private void generatePreview(Path videoPath, int consumerId) {
        try {
            String filename = videoPath.getFileName().toString();
            String previewName = filename.substring(0, filename.lastIndexOf('.')) + "_preview.mp4";
            Path previewsDir = storageDir.resolve("previews");
            Path previewPath = storageDir.resolve("previews").resolve(previewName);

            Files.createDirectories(previewsDir);

            List<String> ffmpegCommand = new ArrayList<>();
            ffmpegCommand.add("ffmpeg");
            ffmpegCommand.add("-i");
            ffmpegCommand.add(videoPath.toAbsolutePath().toString());
            ffmpegCommand.add("-ss");
            ffmpegCommand.add("00:00:00");
            ffmpegCommand.add("-t");
            ffmpegCommand.add("10");
            ffmpegCommand.add("-c:v");
            ffmpegCommand.add("libx264");
            ffmpegCommand.add("-c:a");
            ffmpegCommand.add("aac");
            ffmpegCommand.add("-y");
            ffmpegCommand.add(previewPath.toAbsolutePath().toString());

            ProcessBuilder pb = new ProcessBuilder(ffmpegCommand);
            pb.redirectErrorStream(true);

            Process process = pb.start();

            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            StringBuilder output = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }

            int exitCode = process.waitFor();

            if (exitCode == 0) {
                logger.info("Consumer " + consumerId + " generated preview: " + previewName);
            } else {
                logger.warning("Consumer " + consumerId + " FFmpeg preview failed: " + filename);
                createFallbackPreview(videoPath, previewPath, consumerId);
            }
        } catch (Exception e) {
            logger.warning("Consumer " + consumerId + " preview generation failed: " + e.getMessage());
        }
    }

    private void createFallbackPreview(Path videoPath, Path previewPath, int consumerId) {
        try {
            Files.copy(videoPath, previewPath, StandardCopyOption.REPLACE_EXISTING);
            logger.info("Consumer " + consumerId + " created fallback preview");
        } catch (IOException e) {
            logger.warning("Consumer " + consumerId + " fallback preview failed: " + e.getMessage());
        }
    }

    @Override
    public void getQueueStatus(Empty request, StreamObserver<QueueStatus> responseObserver) {
        boolean isFull = getQueueSize() >= getMaxQueueSize();

        QueueStatus status = QueueStatus.newBuilder()
            .setIsFull(isFull)
            .setCurrentSize(videoQueue.size())
            .setMaxCapacity(videoQueue.getCapacity())
            .build();

        responseObserver.onNext(status);
        responseObserver.onCompleted();
    }

    public int getQueueSize() { return videoQueue.size(); }
    public int getMaxQueueSize() { return videoQueue.getCapacity(); }
    public int getDroppedCount() { return videoQueue.getDroppedCount(); }

    @Override
    public void getVideoList(Empty request, StreamObserver<VideoList> responseObserver) {
        VideoList.Builder videoList = VideoList.newBuilder();
        videoStore.values().forEach(videoList::addVideos);
        responseObserver.onNext(videoList.build());
        responseObserver.onCompleted();
    }

    @Override
    public void getVideo(VideoRequest request, StreamObserver<VideoResponse> responseObserver) {
        try {
            VideoInfo videoInfo = videoStore.get(request.getVideoId());
            if (videoInfo != null) {
                Path filePath = storageDir.resolve(videoInfo.getFilename());
                byte[] data = Files.readAllBytes(filePath);

                responseObserver.onNext(VideoResponse.newBuilder()
                    .setFilename(videoInfo.getFilename())
                    .setData(com.google.protobuf.ByteString.copyFrom(data))
                    .setStatus("SUCCESS")
                    .build());
            } else {
                responseObserver.onNext(VideoResponse.newBuilder()
                    .setStatus("NOT_FOUND")
                    .build());
            }
        } catch (IOException e) {
            responseObserver.onNext(VideoResponse.newBuilder()
                .setStatus("ERROR")
                .build());
        }
        responseObserver.onCompleted();
    }
}

// Renamed class to avoid collision with Protobuf generated class
class QueuedVideo {
    private final String id;
    private final String filename;
    private final String clientId;
    private final byte[] data;

    public QueuedVideo(String id, String filename, String clientId, byte[] data) {
        this.id = id;
        this.filename = filename;
        this.clientId = clientId;
        this.data = data;
    }

    public String getId() { return id; }
    public String getFilename() { return filename; }
    public String getClientId() { return clientId; }
    public byte[] getData() { return data; }
}

// BoundedQueue class - MUST BE ADDED
class BoundedQueue<T> {
    private final List<T> queue;
    private final int capacity;
    private final ReentrantLock lock;
    private final Semaphore emptySlots;
    private final Semaphore filledSlots;
    private int droppedCount;

    public BoundedQueue(int capacity) {
        this.capacity = capacity;
        this.queue = new ArrayList<>(capacity);
        this.lock = new ReentrantLock();
        this.emptySlots = new Semaphore(capacity);
        this.filledSlots = new Semaphore(0);
        this.droppedCount = 0;
    }

    public boolean enqueue(T item) {
        // Try to acquire without blocking - leaky bucket behavior
        if (!emptySlots.tryAcquire()) {
            droppedCount++;
            return false;
        }
        
        lock.lock();
        try {
            queue.add(item);
            filledSlots.release();
            return true;
        } finally {
            lock.unlock();
        }
    }

    public T dequeue() throws InterruptedException {
        filledSlots.acquire();
        lock.lock();
        try {
            T item = queue.remove(0);
            emptySlots.release();
            return item;
        } finally {
            lock.unlock();
        }
    }

    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }

    public int getDroppedCount() {
        return droppedCount;
    }

    public int getCapacity() {
        return capacity;
    }
}
```

## backend/src/main/java/com/example/mediaservice/ProducerClient.java

```java
package com.example.mediaservice;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.logging.*;
import java.util.Properties;

public class ProducerClient {
    private final ManagedChannel channel;
    private final MediaServiceGrpc.MediaServiceBlockingStub blockingStub;
    private final Logger logger;
    private final String clientId;
    private final ExecutorService threadPool;

    public ProducerClient(String host, int port, String clientId, int producerThreads) {
        this.channel = ManagedChannelBuilder.forAddress(host, port)
            .usePlaintext()
            .maxInboundMessageSize(100 * 1024 * 1024)
            // REMOVE keepalive settings to avoid warnings
            .build();
        this.blockingStub = MediaServiceGrpc.newBlockingStub(channel);
        this.clientId = clientId;
        this.threadPool = Executors.newFixedThreadPool(producerThreads);
        
        // Setup file logging
        this.logger = setupLogger(clientId);
    }

    private Logger setupLogger(String clientId) {
        try {
            Logger logger = Logger.getLogger("ProducerClient-" + clientId);
            FileHandler fileHandler = new FileHandler("producer_" + clientId + "_log.txt");
            fileHandler.setFormatter(new SimpleFormatter() {
                @Override
                public String format(LogRecord record) {
                    return String.format("[%1$tF %1$tT] [%2$s] %3$s %4$s%n",
                            new Date(record.getMillis()),
                            Thread.currentThread().getName(),
                            record.getMessage(),
                            record.getThrown() != null ? " - Error: " + record.getThrown().getMessage() : "");
                }
            });
            logger.addHandler(fileHandler);
            logger.setUseParentHandlers(false);
            return logger;
        } catch (IOException e) {
            System.err.println("Failed to setup logger: " + e.getMessage());
            return Logger.getGlobal();
        }
    }

    public void uploadVideo(String filePath) {
        threadPool.submit(() -> {
            String filename = Paths.get(filePath).getFileName().toString();

            // Check queue status before uploading
            while (true) {
                try {
                    QueueStatus status = blockingStub.getQueueStatus(Empty.getDefaultInstance());
                    if (!status.getIsFull()) {
                        break; // Queue has space, proceed to upload
                    }
                    // If full, wait 2 seconds and try again
                    logger.info("Queue is full (" + status.getCurrentSize() + "/" + status.getMaxCapacity() + "). Waiting to upload: " + filename);
                    Thread.sleep(2000);
                } catch (Exception e) {
                    logger.warning("Failed to check queue status: " + e.getMessage());
                    break; // If check fails, try uploading anyway or exit
                }
            }
            
            logger.info("File: " + filename + " Status: Uploading");
            
            try (FileInputStream fis = new FileInputStream(filePath); BufferedInputStream bis = new BufferedInputStream(fis)) {
                byte[] buffer = new byte[1024 * 1024]; // 1MB chunks
                int bytesRead;
                ByteArrayOutputStream fileData = new ByteArrayOutputStream();
                
                while ((bytesRead = bis.read(buffer)) != -1) {
                    fileData.write(buffer, 0, bytesRead);
                }
                
                VideoChunk request = VideoChunk.newBuilder()
                    .setFilename(filename)
                    .setData(com.google.protobuf.ByteString.copyFrom(fileData.toByteArray()))
                    .setClientId(clientId)
                    .build();

                // Add deadline and better error handling
                UploadResponse response;
                try {
                    response = blockingStub
                        .withDeadlineAfter(60, TimeUnit.SECONDS)  // 60 second timeout
                        .uploadVideo(request);
                } catch (io.grpc.StatusRuntimeException e) {
                    // Check if it's a timeout or other gRPC error
                    if (e.getStatus().getCode() == io.grpc.Status.Code.DEADLINE_EXCEEDED) {
                        logger.info("File: " + filename + " Status: Upload timed out (check if video was stored)");
                    } else if (e.getStatus().getCode() == io.grpc.Status.Code.UNAVAILABLE) {
                        logger.info("File: " + filename + " Status: Server unavailable");
                    } else {
                        logger.info("File: " + filename + " Status: gRPC error - " + e.getStatus());
                    }
                    return;
                }

                String status = response.getStatus();
                
                if ("QUEUED".equals(status)) {
                    logger.info("File: " + filename + " Status: Successfully queued (ID: " + response.getVideoId() + ")");
                } else if ("DROPPED".equals(status)) {
                    logger.info("File: " + filename + " Status: Dropped - " + response.getMessage());
                } else if ("ERROR".equals(status)) {
                    logger.info("File: " + filename + " Status: Server error - " + response.getMessage());
                } else {
                    logger.info("File: " + filename + " Status: Server returned - " + status + " - " + response.getMessage());
                }
                
            } catch (IOException e) {
                logger.info("File: " + filename + " Status: Failed to read file - " + e.getMessage());
            } catch (Exception e) {
                logger.info("File: " + filename + " Status: Unexpected error - " + e.getClass().getSimpleName() + ": " + e.getMessage());
            }
        });
    }

    public void scanAndUploadFolder(String folderPath, String[] extensions) {
        try {
            Path folder = Paths.get(folderPath);
            if (!Files.exists(folder) || !Files.isDirectory(folder)) {
                System.out.println("Invalid folder: " + folderPath);
                return;
            }

            Map<String,Path> uniqueFiles = new HashMap<>(); 

            Files.walk(folder) 
                .filter(Files::isRegularFile) 
                .filter(path -> {
                    String filename = path.getFileName().toString().toLowerCase(); 
                    return Arrays.stream(extensions).anyMatch(ext -> filename.endsWith(ext.toLowerCase()));
                }) 
                .forEach(path -> {
                    String filename = path.getFileName().toString(); 
                    String baseName = getBaseFileName(filename); 

                    // Check if we already have file with base name 
                    if (uniqueFiles.containsKey(baseName)) {
                        System.out.println("Skipping duplicate: " + filename + " (duplicate of " + uniqueFiles.get(baseName).getFileName() + ")");
                    } else {
                        uniqueFiles.put(baseName, path); 
                        uploadVideo(path.toString());
                    }
                });

                System.out.println("Found " + uniqueFiles.size() + " unique videos in " + folderPath);
                
        } catch (IOException e) {
            System.err.println("Error scanning folder: " + e.getMessage());
        }
    } 

    public void cleanupDuplicateVideos() {
        try {
            Path videosDir = Paths.get("./videos"); 
            if (!Files.exists(videosDir)) {
                return; 
            } 

            Map<String, List<Path>> fileGroups = new HashMap<>(); 

            // Group files by base name 
            Files.list(videosDir) 
                .filter(Files::isRegularFile)
                .forEach(file -> {
                    String filename = file.getFileName().toString(); 
                    String baseName = getBaseFileName(filename); 
                    fileGroups.computeIfAbsent(baseName, k -> new ArrayList<>()).add(file);
                }); 
            
            // Remove duplicates, only keep original 
            int removedCount = 0; 
            for (Map.Entry<String, List<Path>> entry : fileGroups.entrySet()) {
                List<Path> duplicates = entry.getValue(); 
                if (duplicates.size() > 1) {
                    duplicates.sort((p1, p2) -> {
                        try {
                            return Files.getLastModifiedTime(p1).compareTo(Files.getLastModifiedTime(p2)); 
                        } catch (IOException e) {
                            return 0; 
                        }
                    }); 

                    // Keep the first (oldest file), remove rest 
                    for (int i = 1; i < duplicates.size(); i++) {
                        try {
                            Files.delete(duplicates.get(i)); 
                            removedCount++; 
                            System.out.println("Removed duplicate: " + duplicates.get(i).getFileName());
                        } catch (IOException e) {
                            System.err.println("Failed to remove duplicate: " + duplicates.get(i).getFileName());
                        }
                    }
                }
            }
            
            if (removedCount > 0) {
                System.out.println("Removed " + removedCount + " duplicate files"); 
            }
        } catch (IOException e) {
            System.err.println("Error cleaning up duplicates: " + e.getMessage());
        }
    }

    // Get base filename - MUST BE STATIC
    private static String getBaseFileName(String filename) {
        String nameWithoutExt = filename.replaceFirst("[.][^.]+$", ""); 
        String baseName = nameWithoutExt.replaceAll("\\s*\\(\\d+\\)$", ""); 
        return baseName.toLowerCase();
    }

    // Helper method to scan a single folder
    private static List<Path> scanFolderForVideos(String folderPath, String[] extensions) throws IOException {
        List<Path> videoFiles = new ArrayList<>();
        Path folder = Paths.get(folderPath);
        
        if (!Files.exists(folder) || !Files.isDirectory(folder)) {
            throw new IOException("Invalid folder: " + folderPath);
        }
        
        Files.walk(folder)
            .filter(Files::isRegularFile)
            .filter(path -> {
                String filename = path.getFileName().toString().toLowerCase();
                return Arrays.stream(extensions).anyMatch(ext -> filename.endsWith(ext.toLowerCase()));
            })
            .forEach(videoFiles::add);
        
        return videoFiles;
    }

    // Helper method to remove duplicates across multiple folders
    private static List<Path> removeDuplicatesByBaseName(List<Path> files) {
        Map<String, Path> uniqueFiles = new HashMap<>();
        
        for (Path file : files) {
            String baseName = getBaseFileName(file.getFileName().toString());
            if (!uniqueFiles.containsKey(baseName)) {
                uniqueFiles.put(baseName, file);
            } else {
                System.out.println("Skipping duplicate across folders: " + file.getFileName());
            }
        }
        
        return new ArrayList<>(uniqueFiles.values());
    }

    public void shutdown() {
        threadPool.shutdown();
        try {
            if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
                threadPool.shutdownNow();
            }
        } catch (InterruptedException e) {
            threadPool.shutdownNow();
            Thread.currentThread().interrupt();
        }
        channel.shutdown();
    }

    public static void main(String[] args) {
        // Load configuration from producer-config.properties
        String defaultTargetIp = "localhost";
        int defaultTargetPort = 9090;
        
        Properties config = new Properties();
        try {
            String configPath = "./producer-config.properties";
            if (Files.exists(Paths.get(configPath))) {
                try (FileInputStream fis = new FileInputStream(configPath)) {
                    config.load(fis);
                    System.out.println("Loaded configuration from producer-config.properties");
                }
            } else {
                System.out.println("producer-config.properties not found, using defaults");
            }
        } catch (Exception e) {
            System.err.println("Warning: Could not load producer-config.properties: " + e.getMessage());
            System.err.println("Using default values");
        }
        
        // Read from config file with defaults
        defaultTargetIp = config.getProperty("target.server.ip", defaultTargetIp);
        defaultTargetPort = Integer.parseInt(config.getProperty("target.server.port", String.valueOf(defaultTargetPort)));
        
        Scanner scanner = new Scanner(System.in);
        
        // ========== DEBUG INFO ==========
        System.out.println("=== DEBUG INFO ===");
        System.out.println("Current Working Directory: " + System.getProperty("user.dir"));
        System.out.println("Java Class Location: " + ProducerClient.class.getProtectionDomain().getCodeSource().getLocation());
        
        // Test some common paths
        System.out.println("\n--- Testing Common Paths ---");
        String[] testPaths = {
            "../test-videos1",
            "../test-videos2", 
            "../test-videos3",
            "../test-videos4",
            "../test-videos5",
            "test-videos1",
            "test-videos2",
            "C:\\Users\\arche\\OneDrive\\Documents\\DLSU\\4th Year\\1st Term\\STDISCM\\Problem Set 3\\test-videos1"
        };
        
        for (String path : testPaths) {
            File f = new File(path);
            System.out.println("Path: " + path);
            System.out.println("  Absolute: " + f.getAbsolutePath());
            System.out.println("  Exists: " + f.exists());
            System.out.println("  Is Directory: " + f.isDirectory());
            if (f.exists() && f.isDirectory()) {
                String[] files = f.list((dir, name) -> 
                    name.toLowerCase().endsWith(".mp4") || 
                    name.toLowerCase().endsWith(".avi") || 
                    name.toLowerCase().endsWith(".mov") || 
                    name.toLowerCase().endsWith(".mkv"));
                System.out.println("  Video files found: " + (files != null ? files.length : 0));
            }
            System.out.println();
        }
        System.out.println("==================");
        // ================================

        System.out.println("Choose operation:"); 
        System.out.println("1 - Upload videos with multiple producers");
        System.out.println("2 - Clean up duplicate videos in storage");
        System.out.println("3 - Clean up duplicates THEN upload videos");
        System.out.println("Enter choice (1, 2, or 3): "); 

        String choice = scanner.nextLine().trim();

        // Handle cleanup operations first 
        if ("2".equals(choice) || "3".equals(choice)) {
            ProducerClient cleanupClient = new ProducerClient(defaultTargetIp, defaultTargetPort, "cleanup-client", 1); 
            cleanupClient.cleanupDuplicateVideos(); 

            if ("2".equals(choice)) {
                cleanupClient.shutdown(); 
                scanner.close(); 
                return; 
            } 
            cleanupClient.shutdown();
        }
        
        // Input validation
        int producerThreads = getValidatedInput(scanner, "Enter number of producer threads (p): ", 1);

        System.out.println("Enter target IP address (default: " + defaultTargetIp + "):");
        String targetIp = scanner.nextLine().trim();
        if (targetIp.isEmpty()) {
            targetIp = defaultTargetIp;
        }
        
        // *** ENHANCED INPUT HANDLING WITH DEBUGGING ***
        System.out.println("\n=== FOLDER INPUT ===");
        System.out.println("Enter folder paths (comma separated, e.g., test-videos1, test-videos2, test-videos3):");
        System.out.println("Note: Use '../folder' to go up one level, or full path like 'C:\\path\\to\\folder'");
        
        // Clear scanner buffer if needed
        // if (scanner.hasNextLine()) {
        //     scanner.nextLine(); // Clear any leftover input
        // }
        
        String foldersInput = scanner.nextLine().trim();
        
        System.out.println("\n=== DEBUG: Processing Input ===");
        System.out.println("Raw input received: '" + foldersInput + "'");
        
        // Split by comma and trim each folder path
        String[] folderPaths = foldersInput.split(",");
        System.out.println("Found " + folderPaths.length + " folder paths");
        
        // Enhanced path debugging
        List<String> validFolders = new ArrayList<>();
        for (int i = 0; i < folderPaths.length; i++) {
            String folderPath = folderPaths[i].trim();
            folderPaths[i] = folderPath;
            
            System.out.println("\n--- Analyzing Folder " + (i+1) + " ---");
            System.out.println("Input: '" + folderPath + "'");
            
            // Try to resolve the path
            File folder = new File(folderPath);
            System.out.println("Resolved to: " + folder.getAbsolutePath());
            System.out.println("Exists: " + folder.exists());
            System.out.println("Is directory: " + folder.isDirectory());
            
            if (folder.exists() && folder.isDirectory()) {
                validFolders.add(folderPath);
                
                // List all video files in the directory
                System.out.println("Video files in directory:");
                File[] allFiles = folder.listFiles();
                int videoCount = 0;
                if (allFiles != null) {
                    for (File f : allFiles) {
                        if (f.isFile()) {
                            String name = f.getName().toLowerCase();
                            if (name.endsWith(".mp4") || name.endsWith(".avi") || 
                                name.endsWith(".mov") || name.endsWith(".mkv")) {
                                System.out.println("   " + f.getName());
                                videoCount++;
                            } else {
                                System.out.println("   " + f.getName() + " (not a video)");
                            }
                        }
                    }
                }
                System.out.println("Total video files: " + videoCount);
            } else {
                System.out.println(" WARNING: Folder does not exist or is not a directory!");
            }
        }
        
        System.out.println("\n=== SUMMARY ===");
        System.out.println("Valid folders found: " + validFolders.size() + "/" + folderPaths.length);
        if (validFolders.isEmpty()) {
            System.out.println("No valid folders found. Exiting.");
            scanner.close();
            return;
        }
        
        // Convert list back to array
        folderPaths = validFolders.toArray(new String[0]);
        // =============================================
        
        // Use shared queue approach
        List<Path> allFiles = new ArrayList<>();
        String[] videoExtensions = {".mp4", ".avi", ".mov", ".mkv"};
        
        System.out.println("\n=== SCANNING FOLDERS ===");
        // Scan ALL valid folders once
        for (String folderPath : folderPaths) {
            try {
                System.out.println("\nScanning folder: " + folderPath);
                List<Path> folderFiles = scanFolderForVideos(folderPath, videoExtensions);
                allFiles.addAll(folderFiles);
                System.out.println("Found " + folderFiles.size() + " videos in " + folderPath);
                
                // Debug: List the files found
                if (!folderFiles.isEmpty()) {
                    System.out.println("Files found:");
                    for (Path file : folderFiles) {
                        System.out.println("  - " + file.getFileName());
                    }
                }
            } catch (IOException e) {
                System.err.println("Error scanning " + folderPath + ": " + e.getMessage());
            }
        }
        
        if (allFiles.isEmpty()) {
            System.out.println("No videos found in any folder. Exiting.");
            scanner.close();
            return;
        }
        
        // Remove duplicates across ALL folders
        allFiles = removeDuplicatesByBaseName(allFiles);
        System.out.println("\n=== FINAL FILE LIST ===");
        System.out.println("Total unique videos to upload: " + allFiles.size());
        
        // Debug: Show final list
        System.out.println("Files to upload:");
        for (Path file : allFiles) {
            System.out.println("  - " + file.getFileName() + " (from: " + file.getParent() + ")");
        }
        
        // Create shared queue
        BlockingQueue<Path> fileQueue = new LinkedBlockingQueue<>(allFiles);
        
        // Create producers with shared queue
        List<ProducerClient> producers = new ArrayList<>();
        List<Thread> producerThreadsList = new ArrayList<>();
        CountDownLatch completionLatch = new CountDownLatch(producerThreads);
        
        System.out.println("\n=== STARTING UPLOADS ===");
        System.out.println("Creating " + producerThreads + " producer threads...");
        
        for (int i = 0; i < producerThreads; i++) {
            ProducerClient producer = new ProducerClient(targetIp, defaultTargetPort, "producer-" + (i + 1), 1);
            producers.add(producer);
            
            Thread producerThread = new Thread(() -> {
                String threadName = Thread.currentThread().getName();
                try {
                    System.out.println(threadName + " started");
                    while (true) {
                        // Get file from shared queue (waits if empty)
                        Path file = fileQueue.poll(1, TimeUnit.SECONDS);
                        if (file == null) {
                            // No more files
                            System.out.println(threadName + " finished - no more files");
                            break;
                        }
                        System.out.println(threadName + " uploading: " + file.getFileName());
                        producer.uploadVideo(file.toString());
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    System.out.println(threadName + " interrupted");
                } finally {
                    completionLatch.countDown();
                    System.out.println(threadName + " completed");
                }
            }, "Producer-" + (i + 1));
            
            producerThreadsList.add(producerThread);
            producerThread.start();
        }
        
        System.out.println("\n" + producerThreads + " producers started. Uploading " + allFiles.size() + " videos...");
        System.out.println("Waiting for uploads to complete...");
        
        // Wait for all producers to finish
        try {
            boolean completed = completionLatch.await(30, TimeUnit.MINUTES); // 30 minute timeout
            if (completed) {
                System.out.println(" All uploads completed!");
            } else {
                System.out.println(" Timeout - some uploads may not have completed");
            }
        } catch (InterruptedException e) {
            System.err.println(" Upload waiting interrupted");
            e.printStackTrace();
        }
        
        // Cleanup
        System.out.println("\n=== CLEANUP ===");
        producers.forEach(ProducerClient::shutdown);
        scanner.close();
        System.out.println("All producers stopped.");
    }
    
    private static int getValidatedInput(Scanner scanner, String prompt, int minValue) {
        while (true) {
            System.out.print(prompt);
            try {
                int value = Integer.parseInt(scanner.nextLine());
                if (value >= minValue) {
                    return value;
                } else {
                    System.out.println("Value must be at least " + minValue);
                }
            } catch (NumberFormatException e) {
                System.out.println("Please enter a valid number");
            }
        }
    }
}
```

## backend/src/main/proto/media.proto

```text
syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.example.mediaservice";

service MediaService {
  rpc UploadVideo (VideoChunk) returns (UploadResponse);
  rpc GetVideoList (Empty) returns (VideoList);
  rpc GetVideo (VideoRequest) returns (VideoResponse);
  rpc GetQueueStatus (Empty) returns (QueueStatus);
}

// Simplified to match ProducerClient.java logic
message VideoChunk {
  string filename = 1;
  string client_id = 2;
  bytes data = 3;
}

message QueueStatus {
  bool is_full = 1;
  int32 current_size = 2;
  int32 max_capacity = 3;
}

message UploadResponse {
  string status = 1; // "SUCCESS", "QUEUED", "DROPPED", "FAILED"
  string message = 2;
  string video_id = 3;
}

message Empty {}

message VideoList {
  repeated VideoInfo videos = 1;
}

message VideoInfo {
  string id = 1;
  string filename = 2;
  string upload_time = 3;
  int64 size = 4; 
  string client_id = 5;
  int64 compressed_size = 6;
}

message VideoRequest {
  string video_id = 1;
}

message VideoResponse {
  string filename = 1;
  bytes data = 2;
  string status = 3;
}
```

## frontend/.gitignore

```text
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

## frontend/config.json

```json
{
  "SERVER_IP": "localhost",
  "SERVER_PORT": "8080"
}
```

## frontend/eslint.config.js

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])
```

## frontend/index.html

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

## frontend/package.json

```json
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.2",
    "@types/react-dom": "^19.2.2",
    "@vitejs/plugin-react": "^5.1.0",
    "babel-plugin-react-compiler": "^1.0.0",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "npm:rolldown-vite@7.2.2"
  },
  "overrides": {
    "vite": "npm:rolldown-vite@7.2.2"
  }
}
```

## frontend/README.md

```markdown
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is enabled on this template. See [this documentation](https://react.dev/learn/react-compiler) for more information.

Note: This will impact Vite dev & build performances.

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
```

## frontend/src/App.jsx

```text
import React, { useState, useEffect } from 'react'
import VideoGrid from './components/VideoGrid'
import VideoPlayer from './components/VideoPlayer'
import './styles/App.css'
import configData from '../config.json'

// Load server configuration from config.json with fallback to defaults
const SERVER_IP = configData?.SERVER_IP || 'localhost';
const SERVER_PORT = configData?.SERVER_PORT || '8080';

function App() {
  const [videos, setVideos] = useState([])
  const [selectedVideo, setSelectedVideo] = useState(null)
  const [stats, setStats] = useState({ queueSize: 0, maxQueue: 10, droppedCount: 0 })
  const [lastDroppedCount, setLastDroppedCount] = useState(0)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    fetchData()
    const interval = setInterval(fetchData, 2000)
    return () => clearInterval(interval)
  }, [])

  const fetchData = async () => {
    try {
      setError(null)
      
      // Fetch stats
      const statsResponse = await fetch(`http://${SERVER_IP}:${SERVER_PORT}/api/stats`)
      if (!statsResponse.ok) throw new Error('Failed to fetch stats')
      const statsData = await statsResponse.json()
      setStats(statsData)

      // Check for new dropped videos
      if (statsData.droppedCount > lastDroppedCount) {
        setLastDroppedCount(statsData.droppedCount)
        triggerDropAlert()
      }

      // Fetch videos list
      const videosResponse = await fetch(`http://${SERVER_IP}:${SERVER_PORT}/api/videos`)
      if (!videosResponse.ok) throw new Error('Failed to fetch videos')
      const videosData = await videosResponse.json()
      setVideos(videosData)
      
      setLoading(false)
    } catch (error) {
      console.error('Error fetching data:', error)
      setError(error.message)
      setLoading(false)
    }
  }

  const triggerDropAlert = () => {
    // Visual alert for dropped videos
    const alertElement = document.createElement('div')
    alertElement.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #ff4444;
      color: white;
      padding: 15px;
      border-radius: 5px;
      z-index: 1000;
      animation: flash 1s 3;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    `
    alertElement.textContent = ' Video dropped due to queue overflow!'
    document.body.appendChild(alertElement)
    
    setTimeout(() => {
      if (document.body.contains(alertElement)) {
        document.body.removeChild(alertElement)
      }
    }, 3000)
  }

  const calculatePercentage = () => {
    return stats.maxQueue > 0 ? (stats.queueSize / stats.maxQueue) * 100 : 0
  }

  if (loading) {
    return (
      <div className="app">
        <header className="app-header">
          <h1>Media Upload Service</h1>
          <p>Loading...</p>
        </header>
      </div>
    )
  }

  return (
    <div className="app">
      <header className="app-header">
        <h1>Media Upload Service</h1>
        <p>Distributed Producer-Consumer System</p>
        
        {error && (
          <div className="error-banner">
            Error: {error}. Make sure the backend server is running on {SERVER_IP}:{SERVER_PORT}
          </div>
        )}
        
        {/* Stats Display */}
        <div className="stats-container">
          <div className="stat-item">
            <span className="stat-label">Queue:</span>
            <span className="stat-value">{stats.queueSize}/{stats.maxQueue}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Dropped:</span>
            <span className="stat-value dropped">{stats.droppedCount}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Videos:</span>
            <span className="stat-value">{videos.length}</span>
          </div>
        </div>

        {/* Progress Bar */}
        <div className="progress-container">
          <div 
            className="progress-bar"
            style={{ width: `${calculatePercentage()}%` }}
          ></div>
        </div>
      </header>
      
      <main className="app-main">
        {selectedVideo ? (
          <VideoPlayer 
            video={selectedVideo} 
            onBack={() => setSelectedVideo(null)}
            serverIp={SERVER_IP}
            serverPort={SERVER_PORT}
          />
        ) : (
          <VideoGrid 
            videos={videos}
            onVideoSelect={setSelectedVideo}
            serverIp={SERVER_IP}
            serverPort={SERVER_PORT}
          />
        )}
      </main>
    </div>
  )
}

export default App
```

## frontend/src/components/VideoGrid.jsx

```text
import React from 'react'

const VideoGrid = ({ videos, onVideoSelect, serverIp, serverPort }) => {
    // Deduplication - highlight duplicates
    const findDuplicates = (videoList) => {
        const seen = new Set();
        const duplicates = new Set();
        videoList.forEach(video => {
            const baseName = video.filename.replace(/\(\d+\)\.\w+$/, '.mp4');
            if (seen.has(baseName)) {
                duplicates.add(baseName);
            } else {
                seen.add(baseName);
            }
        });
        return duplicates;
    };

    const duplicates = findDuplicates(videos);

    return (
        <div className="video-grid">
            <h2>Uploaded Videos ({videos.length})</h2>
            {videos.length === 0 ? (
                <div className="no-videos">
                    <p>No videos uploaded yet. Use the ProducerClient to upload videos.</p>
                </div>
            ) : (
                <div className="grid">
                    {videos.map(video => (
                        <VideoCard
                            key={video.id}
                            video={video}
                            onSelect={onVideoSelect}
                            isDuplicate={duplicates.has(video.filename.replace(/\(\d+\)\.\w+$/, '.mp4'))}
                            serverIp={serverIp}
                            serverPort={serverPort}
                        />
                    ))}
                </div>
            )}
        </div>
    )
}

const VideoCard = ({ video, onSelect, isDuplicate, serverIp, serverPort }) => {
    const [isHovered, setIsHovered] = React.useState(false);
    const [previewError, setPreviewError] = React.useState(false);

    const handleMouseEnter = () => {
        setIsHovered(true);
        setPreviewError(false);
    };

    const handleMouseLeave = () => {
        setIsHovered(false);
    };

    // Construct URLs for video content
    const previewFilename = video.filename.replace('.mp4', '_preview.mp4');
    const previewUrl = `http://${serverIp}:${serverPort}/content/previews/${previewFilename}`;

    const handlePreviewError = () => {
        setPreviewError(true);
    };

    // Calculate savings percentage
    const savings = video.compressed_size > 0
        ? ((1 - (video.compressed_size / video.size)) * 100).toFixed(0)
        : 0;

    return (
        <div
            className={`video-card ${isDuplicate ? 'duplicate' : ''}`}
            onMouseEnter={handleMouseEnter}
            onMouseLeave={handleMouseLeave}
            onClick={() => onSelect(video)}
        >
            {isDuplicate && <div className="duplicate-badge">DUPLICATE</div>}

            {/* Show Savings Badge if compressed */}
            {video.compressed_size > 0 && (
                <div className="savings-badge">
                    -{savings}% Size
                </div>
            )}

            <div className="video-thumbnail">
                {isHovered && !previewError ? (
                    <div className="video-preview">
                        <video
                            src={previewUrl}
                            autoPlay
                            muted
                            loop
                            onError={handlePreviewError}
                        />
                        <div className="preview-label">10s Preview</div>
                    </div>
                ) : (
                    <div className="video-placeholder">
                        <span></span>
                        <div className="placeholder-text">Hover to preview</div>
                    </div>
                )}
            </div>

            <div className="video-info">
                <h4 title={video.filename}>{video.filename}</h4>

                {/* NEW: Compression Stats Display */}
                <div className="size-info">
                    {video.compressed_size > 0 ? (
                        <div className="compression-row">
                            <span className="old-size">
                                {(video.size / 1024 / 1024).toFixed(2)} MB
                            </span>
                            <span className="arrow"></span>
                            <span className="new-size">
                                {(video.compressed_size / 1024 / 1024).toFixed(2)} MB
                            </span>
                        </div>
                    ) : (
                        <p className="normal-size">Size: {(video.size / 1024 / 1024).toFixed(2)} MB</p>
                    )}
                </div>

                <p className="meta-text">Uploaded: {new Date(video.upload_time).toLocaleTimeString()}</p>
                {video.client_id && <p className="meta-text">Client: {video.client_id}</p>}
            </div>
        </div>
    );
};

export default VideoGrid;
```

## frontend/src/components/VideoPlayer.jsx

```text
import React from 'react'

const VideoPlayer = ({ video, onBack, serverIp, serverPort }) => {
    const videoUrl = `http://${serverIp}:${serverPort}/content/videos/${video.filename}`;
    const compressedVideoUrl = `http://${serverIp}:${serverPort}/content/compressed/compressed_${video.filename}`;

    return (
        <div className="video-player">
            <button className="back-button" onClick={onBack}>
                 Back to Gallery
            </button>
            
            <div className="player-container">
                <h2>{video.filename}</h2>
                <div className="video-wrapper">
                    <video 
                        controls 
                        autoPlay 
                        className="main-video"
                        src={videoUrl}
                    />
                </div>

                <div className="video-details">
                    <p><strong>ID:</strong> {video.id}</p>
                    <p><strong>Uploaded:</strong> {new Date(video.upload_time).toLocaleString()}</p>
                    {video.client_id && <p><strong>Uploaded by:</strong> {video.client_id}</p>}

                    <div style={{marginTop: '20px', padding: '15px', background: '#f5f5f5', borderRadius: '8px', border: '1px solid #ddd'}}>
                        <h3>Compression Stats</h3>
                        <p><strong>Original Size:</strong> {(video.size / 1024 / 1024).toFixed(2)} MB</p>

                        {video.compressed_size > 0 ? (
                            <>
                                <p><strong>Compressed Size:</strong> {(video.compressed_size / 1024 / 1024).toFixed(2)} MB</p>
                                <p style={{color: '#4caf50', fontWeight: 'bold'}}>
                                    Saved: {((1 - (video.compressed_size / video.size)) * 100).toFixed(1)}% space
                                </p>
                                <a
                                    href={compressedVideoUrl}
                                    target="_blank"
                                    rel="noreferrer"
                                    style={{display: 'inline-block', marginTop: '10px', color: '#2196f3'}}
                                >
                                    View Compressed Video
                                </a>
                            </>
                        ) : (
                            <p><em>Compression pending or not available...</em></p>
                        )}
                    </div>
                </div>
            </div>
        </div>
    )
}

export default VideoPlayer
```

## frontend/src/index.css

```css
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
```

## frontend/src/main.jsx

```text
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './styles/App.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
```

## frontend/src/styles/App.css

```css
* {
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
} 

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    background-color: #f5f5f5;
    color: #333;
} 

.app {
    min-height: 100vh; 
}

.app-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
    color: white; 
    padding: 2rem; 
    text-align: center;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
} 

.app-header h1 {
    font-size: 2.5rem; 
    margin-bottom: 0.5rem; 
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
} 

.app-header p {
    opacity: 0.9; 
    font-size: 1.1rem; 
    margin-bottom: 1rem;
} 

.error-banner {
    background: rgba(255, 68, 68, 0.9);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    font-size: 0.9rem;
}

.app-main {
    padding: 2rem; 
    max-width: 1400px; 
    margin: 0 auto;
} 

/* Stats styling */
.stats-container {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin: 20px 0;
    flex-wrap: wrap;
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: rgba(255, 255, 255, 0.1);
    padding: 10px 20px;
    border-radius: 10px;
    backdrop-filter: blur(10px);
}

.stat-label {
    font-size: 0.9rem;
    opacity: 0.8;
    margin-bottom: 5px;
}

.stat-value {
    font-size: 1.4rem;
    font-weight: bold;
}

.stat-value.dropped {
    color: #ff6b6b;
}

/* Progress bar */
.progress-container {
    width: 400px;
    height: 20px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    overflow: hidden;
    margin: 20px auto;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

/* Video Grid */
.video-grid h2 {
    margin-bottom: 1.5rem; 
    color: #333; 
    text-align: center;
    font-size: 2rem;
} 

.no-videos {
    text-align: center;
    padding: 3rem;
    color: #666;
    font-size: 1.1rem;
}

.grid {
    display: grid; 
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); 
    gap: 2rem;
} 

.video-card {
    background: white; 
    border-radius: 12px; 
    overflow: hidden; 
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); 
    cursor: pointer; 
    transition: all 0.3s ease;
    position: relative;
} 

.video-card:hover {
    transform: translateY(-8px);
    box-shadow: 0 12px 25px rgba(0, 0, 0, 0.15);
}

/* Duplicate styling */
.video-card.duplicate {
    border: 3px solid #ff4444;
    animation: pulse 2s infinite;
}

.duplicate-badge {
    position: absolute;
    top: 10px;
    right: 10px;
    background: #ff4444;
    color: white;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: bold;
    z-index: 10;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.video-thumbnail {
  position: relative;
  width: 100%;
  height: 220px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  overflow: hidden;
}

.video-placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  font-size: 3rem;
  color: white;
}

.placeholder-text {
    font-size: 0.9rem;
    margin-top: 10px;
    opacity: 0.8;
}

.video-preview {
  position: relative;
  height: 100%;
  background: #000;
}

.video-preview video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.preview-label {
  position: absolute;
  bottom: 8px;
  right: 8px;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 0.8rem;
}

.video-info {
  padding: 1.2rem;
}

.video-info h4 {
  margin-bottom: 0.8rem;
  color: #333;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 1.1rem;
}

.video-info p {
  font-size: 0.9rem;
  color: #666;
  margin-bottom: 0.4rem;
}

/* Video Player */
.video-player {
  max-width: 900px;
  margin: 0 auto;
}

.back-button {
  background: #667eea;
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  cursor: pointer;
  margin-bottom: 1.5rem;
  font-size: 1rem;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.back-button:hover {
  background: #5a6fd8;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.player-container {
  background: white;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
}

.player-container h2 {
  margin-bottom: 1.5rem;
  color: #333;
  text-align: center;
  font-size: 1.5rem;
}

.video-wrapper {
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    margin-bottom: 2rem;
}

.main-video {
  width: 100%;
  display: block;
}

.video-details {
  background: #f8f9fa;
  padding: 1.5rem;
  border-radius: 8px;
  border-left: 4px solid #667eea;
}

.video-details p {
  margin-bottom: 0.8rem;
  color: #555;
  font-size: 1rem;
}

/* Animations */
@keyframes flash {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.4); }
  70% { box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); }
  100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); }
}

/* Responsive */
@media (max-width: 768px) {
    .grid {
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 1rem;
    }
    
    .app-main {
        padding: 1rem;
    }
    
    .stats-container {
        gap: 15px;
    }
    
    .stat-item {
        padding: 8px 15px;
    }
    
    .progress-container {
        width: 300px;
    }
}

/* --- IMPROVED CARD STYLES --- */

/* 1. Make sure the card handles absolute positioning correctly */
.video-card {
    position: relative;
    display: flex;
    flex-direction: column;
    height: 100%; /* Ensure uniform height */
}

/* 2. The Green Badge - Floating on top of the thumbnail */
.savings-badge {
    position: absolute;
    top: 12px;
    left: 12px;
    background: #10b981; /* Modern Emerald Green */
    color: white;
    padding: 4px 10px;
    border-radius: 20px; /* Pill shape */
    font-size: 0.75rem;
    font-weight: 700;
    z-index: 10;
    box-shadow: 0 2px 8px rgba(0,0,0,0.25);
    letter-spacing: 0.5px;
}

/* 3. Container for the file info */
.video-info {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem; /* Adds space between elements */
    flex-grow: 1;
}

.video-info h4 {
    font-size: 1.1rem;
    margin: 0;
    color: #1f2937;
    font-weight: 600;
}

/* 4. The Compression Stats Box */
.size-info {
    background: #f0fdf4; /* Very light green background */
    border: 1px solid #dcfce7;
    border-radius: 8px;
    padding: 8px 12px;
    margin-top: auto; /* Pushes it down if there's extra space */
    width: fit-content; /* Makes the box only as wide as the text */

}

.compression-row {
    display: flex;
    align-items: center;
    gap: 15px; /* <--- ADD THIS LINE */
    font-family: 'Roboto Mono', monospace;
    font-size: 0.85rem;
}

.old-size {
    text-decoration: line-through;
    color: #9ca3af; /* Light gray */
}

.arrow {
    color: #6b7280;
    font-size: 0.8rem;
}

.new-size {
    color: #059669; /* Darker Green */
    font-weight: 700;
    background: #d1fae5;
    padding: 2px 6px;
    border-radius: 4px;
}

/* 5. Metadata (Date, Client) */
.meta-text {
    font-size: 0.75rem !important;
    color: #6b7280;
    margin: 0 !important;
    display: flex;
    align-items: center;
    gap: 4px;
}

/* 6. Standard size text (for uncompressed videos) */
.normal-size {
    background: #f3f4f6;
    color: #4b5563;
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 0.85rem;
    display: inline-block;
    font-weight: 500;
}
```

## frontend/vite.config.js

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
// export default defineConfig({
//   plugins: [
//     react({
//       babel: {
//         plugins: [['babel-plugin-react-compiler']],
//       },
//     }),
//   ],
// })

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000
  }
})
```

## README.md

````markdown
# Media Upload Service - Distributed Producer-Consumer System 
A distributed media upload platform that streams videos between producers and consumers with queue management and video previews. This project is built with Java gRPC for the backend and React for the frontend web application. 

## System Architecture 
```
    gRPC         HTTP     
   Producer           Media Server      React Frontend 
  (Java Client)                  (Java gRPC)                    (Web GUI)    
                          
                                                                             
  Video Files                    Queue Management                Video Display 
  Folder Scanning                Preview Generation              Real-time Stats
  Duplicate Prevention           File Storage                   Hover Previews 
```


## Prerequisites 
### **Backend Dependencies** 
- Java 20 or higher 
- Maven 3.6+ 
- FFmpeg (for video preview generation) 

### **Frontend Dependencies** 
- Node.js 16+ and npm 
- React 18+ 

## Installation & Setup Instructions 
### 1. Backend Setup (Java + Maven) 
Install Java 
- Windows: Download from https://www.oracle.com/java/technologies/javase/jdk22-archive-downloads.html 

Verify Installation: 
- java --version 
- javac --version

Install Maven
- Windows: Download from https://maven.apache.org/download.cgi 

Verify Installation: 
- mvn --version 

Install FFmpeg (For previews) 
- Download from https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-full.7z 
- Extract to **C:\ffmpeg** 
- Add **C:\ffmpeg\bin** to you PATH environment variables 
- Restart 

### 2. Frontend Setup (React + Node.js) 
Install Node.js 
- Download from https://nodejs.org/en 
- Recommended version: 20 or higher 

Verify installation: 
- node --version 
- npm --version 

## Running Application 
### **Important:** Run in Separate Terminals
3 separate terminals will be needed for proper operation

#### Terminal 1: Backend Media Server 
- cd backend 
- mvn clean compile 
- mvn exec:java -D"exec.mainClass=com.example.mediaservice.MediaServer" 

#### Expected Output: 
Media Server started: 
gRPC Server on port: 9090 (0.0.0.0) 
HTTP Server on Port: 8080 
Static content available at: http://[SERVER_IP]:8080/content/ 

#### Terminal 2: Producer Client (Video Upload) 
- cd backend 
- mvn clean compile 
- mvn exec:java -D"exec.mainClass=com.example.mediaservice.ProducerClient" 

#### Producer Client Interaction: 
Choose operation:
1 - Upload videos with multiple producers
2 - Clean up duplicate videos in storage
Enter choice (1 or 2): 1

Enter number of producer threads (p): 2
Enter number of consumer threads (c): 3
Enter queue size (q): 10
Enter target IP address: localhost
Enter folder path for producer thread 1: ../test-videos
Enter folder path for producer thread 2: ../test-videos

Producers started. Press 'q' to quit.

#### Terminal 3: Frontend React Application 
- cd frontend 
- npm install 
- npm run dev 

## Multi-VM Deployment

The system can be deployed across multiple virtual machines for distributed operation. Each component can run on a separate VM.

### VM Setup Overview
- **VM 1**: MediaServer (gRPC + HTTP server)
- **VM 2**: ProducerClient (video upload client)
- **VM 3**: React Frontend (web application)

### Configuration Files

The system uses configuration files to specify IP addresses and ports for multi-VM deployment:

#### 1. MediaServer Configuration (`backend/config.properties`)
```properties
# gRPC server port (default: 9090)
grpc.port=9090

# HTTP server port (default: 8080)
http.port=8080

# Maximum queue size (default: 10)
queue.size=10

# Number of consumer threads (default: 3)
consumer.threads=3

# Bind address - use 0.0.0.0 to accept connections from any IP
bind.address=0.0.0.0
```

**Important**: Set `bind.address=0.0.0.0` to allow connections from other VMs. For security, you can restrict to specific IPs.

#### 2. ProducerClient Configuration (`backend/producer-config.properties`)
```properties
# Target MediaServer IP address
# Replace with the IP address of the VM running MediaServer
target.server.ip=192.168.1.100

# Target MediaServer gRPC port (default: 9090)
target.server.port=9090
```

**Important**: Replace `192.168.1.100` with the actual IP address of the VM running MediaServer.

#### 3. Frontend Configuration (`frontend/config.json`)
```json
{
  "SERVER_IP": "192.168.1.100",
  "SERVER_PORT": "8080"
}
```

**Important**: Replace `192.168.1.100` with the actual IP address of the VM running MediaServer.

### Multi-VM Deployment Steps

#### Step 1: Setup MediaServer VM
1. Copy the entire project to VM 1
2. Edit `backend/config.properties`:
   - Set `bind.address=0.0.0.0` (to accept connections from other VMs)
   - Configure ports as needed
3. Start MediaServer:
   ```bash
   cd backend
   mvn clean compile
   mvn exec:java -D"exec.mainClass=com.example.mediaservice.MediaServer"
   ```
4. Note the VM's IP address (e.g., `192.168.1.100`)

#### Step 2: Setup ProducerClient VM
1. Copy the entire project to VM 2
2. Edit `backend/producer-config.properties`:
   - Set `target.server.ip` to the MediaServer VM's IP address
   - Set `target.server.port` to match MediaServer's gRPC port
3. Start ProducerClient:
   ```bash
   cd backend
   mvn clean compile
   mvn exec:java -D"exec.mainClass=com.example.mediaservice.ProducerClient"
   ```
4. When prompted for target IP, you can press Enter to use the config file value, or override it

#### Step 3: Setup Frontend VM
1. Copy the entire project to VM 3
2. Edit `frontend/config.json`:
   - Set `SERVER_IP` to the MediaServer VM's IP address
   - Set `SERVER_PORT` to match MediaServer's HTTP port
3. Start the frontend:
   ```bash
   cd frontend
   npm install
   npm run dev
   ```
4. Access the web application from any browser

### Command-Line Overrides

All components support command-line arguments that override configuration file values:

**MediaServer**:
```bash
mvn exec:java -D"exec.mainClass=com.example.mediaservice.MediaServer" -Dexec.args="9090 8080 10 3 0.0.0.0"
# Arguments: [grpcPort] [httpPort] [queueSize] [consumerThreads] [bindAddress]
```

**ProducerClient**: The target IP can be overridden when prompted during execution.

### Network Requirements

- All VMs must be on the same network or have network connectivity
- Firewall rules must allow:
  - MediaServer VM: Incoming connections on gRPC port (default: 9090) and HTTP port (default: 8080)
  - ProducerClient VM: Outgoing connections to MediaServer gRPC port
  - Frontend VM: Outgoing connections to MediaServer HTTP port
- For cloud deployments, ensure security groups/network rules are configured appropriately

### Testing Multi-VM Setup

1. Verify MediaServer is accessible:
   ```bash
   # From ProducerClient VM or Frontend VM
   curl http://[MEDIA_SERVER_IP]:8080/api/stats
   ```

2. Check network connectivity:
   ```bash
   # From ProducerClient VM
   ping [MEDIA_SERVER_IP]
   
   # Test gRPC port (if netcat/telnet available)
   telnet [MEDIA_SERVER_IP] 9090
   ```

## Project Structure 
```
Problem Set 3/
 backend/
    pom.xml                          # Maven dependencies
    config.properties                # MediaServer configuration
    producer-config.properties       # ProducerClient configuration
    src/main/
       proto/media.proto            # gRPC service definition
       java/com/example/mediaservice/
           MediaServer.java         # Main server (gRPC + HTTP)
           MediaServiceImpl.java    # Business logic
           ProducerClient.java      # Video upload client
           BoundedQueue.java        # Leaky bucket queue
    videos/                          # Auto-created: stored videos
    target/                          # Auto-created: compiled classes
 frontend/
    package.json                     # React dependencies
    vite.config.js                   # Vite configuration
    config.json                      # Frontend configuration
    src/
        App.jsx                      # Main React component
        main.jsx                     # React entry point
        components/
           VideoGrid.jsx            # Video gallery
           VideoPlayer.jsx          # Video player
        styles/
            App.css                  # Styling
 test-videos/                         # Test videos storage
```

## Configurations 
### Backend Configuration (MediaServer) 
Configuration is managed via `backend/config.properties`:
- **grpc.port**: gRPC port (default: 9090) 
- **http.port**: HTTP port (default: 8080) 
- **queue.size**: Max queue capacity (default: 10) 
- **consumer.threads**: Number of processing threads (default: 3)
- **bind.address**: Bind address for servers (default: 0.0.0.0 for multi-VM)

Command-line arguments can override config file values:
```bash
mvn exec:java -D"exec.mainClass=com.example.mediaservice.MediaServer" -Dexec.args="[grpcPort] [httpPort] [queueSize] [consumerThreads] [bindAddress]"
```

### Producer Configuration 
Configuration is managed via `backend/producer-config.properties`:
- **target.server.ip**: Target MediaServer IP address (default: localhost)
- **target.server.port**: Target MediaServer gRPC port (default: 9090)

Runtime configuration:
- **Producer Threads**: Number of parallel uploaders (entered at runtime)
- **Consumer Threads**: Server-side processing threads (entered at runtime)
- **Queue Size**: Server queue capacity (entered at runtime)
- **Target IP**: Can be overridden when prompted (uses config file as default)

### Frontend Configuration
Configuration is managed via `frontend/config.json`:
- **SERVER_IP**: MediaServer IP address (default: localhost)
- **SERVER_PORT**: MediaServer HTTP port (default: 8080) 

## Key Features 
### Backend Features 
- **Distributed gRPC Communication**: Efficient binary protocol 
- **Leaky Bucket Queue**: Configurable queue with drop policy 
- **Multi-threaded Processing**: Parallel video processing 
- **FFmpeg Integration**: Automatic 10-second preview generation 
- **Duplicate Prevention**: Smart filename handling 
- **REST API**: HTTP endpoints for frontend communcation 

### Frontend Features 
- **Real-time Updates**: Live queue statistics every 2 seconds 
- **Hover Previews**: 10-second video preview on mouse hover 
- **Video Player**: Full-screen video playback 
- **Duplicate Detection**: Visual indicator for duplicate files 
- **Progress Visualization**: Queue capacity progress bar 

## Troubleshooting 
### Common Issues 
1. FFmpeg not found 
- Verify FFmpege installation: **ffmpeg --version** 
- Check PATH environment variable 
- Restart 

2. Maven compilation errors 
- mvn clean 
- mvn compile 

3. Frontend dependency issues 
- rm -rf node_modules package-lock.json 
- npm install
````

## Statistics

- Total Files: 20
- Total Characters: 96840
- Total Tokens: 0
